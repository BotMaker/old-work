--  code generated by Win32Lib IDE v0.21.1 Build Sept-29-2006

constant TheProgramType="exw" 
 
include Win32Lib.ew
without warning

--------------------------------------------------------------------------------
--  Window Window1
constant Window1 = createEx( Window, "StarCraft Editor", 0, Default, Default, 636, 490, 0, 0 )
sequence IDEFlags
IDEFlags = classDefaults( Window, { {1, {WS_SYSMENU}},{2, {WS_EX_STATICEDGE}} } )
constant CWindow2 = createEx( Window, "", Window1, 0, 50, 200, 400, w32or_all({WS_CHILD, WS_CLIPSIBLINGS}), w32or_all({WS_EX_STATICEDGE}) )
openWindow(CWindow2, Normal)
moveZOrder( CWindow2, HWND_TOP)
IDEFlags = classDefaults( Window, { {1, {WS_SYSMENU}},{2, {WS_EX_STATICEDGE}} } )
constant CWindow1 = createEx( Window, "", Window1, 200, 50, 430, 400, w32or_all({WS_CHILD, WS_CLIPSIBLINGS, WS_VSCROLL, WS_HSCROLL}), w32or_all({WS_EX_STATICEDGE}) )
openWindow(CWindow1, Normal)
moveZOrder( CWindow1, HWND_TOP)
IDEFlags = classDefaults( Window, { {1, {WS_SYSMENU}},{2, {WS_EX_STATICEDGE}} } )
constant CWindow3 = createEx( Window, "", CWindow2, 6, 256, 180, 160, w32or_all({WS_CHILD, WS_CLIPSIBLINGS, WS_VSCROLL}), w32or_all({WS_EX_STATICEDGE}) )
openWindow(CWindow3, Normal)
moveZOrder( CWindow3, HWND_TOP)
constant toolbar1 = createEx( ToolBar, "", Window1, 0, -34, 636, 34, 0, 0 )
---------------------------------------------------------
--------------------------------------------------------------------------------
include euallegro.ew as allegro
include reg.ew
include win32dib.ew
include xControls.ew
include toolbar.ew
include picture_button.ew




--fix a problem with the ide and the vertacl spliter cwindow
IDEFlags = classDefaults(Window, { {1, {WS_SYSMENU}},{2, {WS_EX_DLGMODALFRAME}} } )--


constant window_titlebar_height = getSystemMetrics ( SM_CYCAPTION )
constant window_menu_height = getSystemMetrics ( SM_CYMENU )
constant window_hscrollbar_width = getSystemMetrics ( SM_CXVSCROLL )
constant window_vscrollbar_height = getSystemMetrics ( SM_CYVSCROLL )
constant window_border_width = getSystemMetrics ( SM_CXFRAME )
constant window_border_height = getSystemMetrics ( SM_CYFRAME )
constant window_toolbar_height = 33

constant window_all_height=window_titlebar_height+window_menu_height+window_toolbar_height+(getSystemMetrics ( SM_CYFRAME )*2)

function real(sequence string)
sequence temp
temp=value(string)
return temp[2]
end function

procedure centerwindow(integer win)
integer width,height,window_width,window_height
sequence size
    size=getCtlSize(win)
    window_width=size[1]
    window_height=size[2]
    width=w32Func(xGetSystemMetrics,{SM_CXSCREEN})
    height=w32Func(xGetSystemMetrics,{SM_CYSCREEN})
    setRect( win,floor((width/2))-floor((window_width/2)) ,floor((height/2))-floor((window_height/2))-32, window_width, window_height, 0 )
end procedure

function rgb2( integer r, integer g, integer b )
    return makecol(r,g,b)
end function

function get_file_fullname_part(sequence fname)
    for i=length(fname) to 1 by -1 do
    	if fname[i]='\\' then
    	   return fname[i+1..length(fname)]
    	end if
    end for
    return fname
end function

function get_file_name_part(sequence fname)
    for i=length(fname) to 1 by -1 do
    	if fname[i]='\\' then
    	   for j=length(fname) to i by -1 do
    	   	  if fname[j]='.' then
    	   	  	return fname[i+1..j-1]
    	   	  end if
    	   end for
    	   return fname[i+1..length(fname)]
    	end if
    end for
    --maybe theres no path just a name
    for i=length(fname) to 1 by -1 do
    	if fname[i]='.' then
    	   return fname[1..i-1]
    	end if
    end for
end function

function file_exsist(sequence fname)
  integer fn
  fn=open(fname,"r")
  if fn!=-1  then
    close(fn)
  	return 1
  end if
  return 0
end function

function get_file_ext_part(sequence fname)
    for i=length(fname) to 1 by -1 do
    	if fname[i]='.' then
    	   return lower(fname[i+1..length(fname)])
    	end if
    end for
end function

function get_file_path_part(sequence fname)
    for i=length(fname) to 1 by -1 do
    	if fname[i]='\\' then
    		return fname[1..i]
    	end if
    end for
end function


function remove_line(sequence string, integer line)
sequence temp
integer len
len=length(string)
if line=1 then
  return string[2..len]
elsif line=len then
  return string[1..len-1]
else
  temp=string[1..line-1]
  return temp&string[line+1..len]
end if
end function

sequence key_buffer
key_buffer={}

procedure key_add(integer scancode)
integer found
found=0
  for i=1 to length(key_buffer) do
    if key_buffer[i]=scancode then
      found=1
      exit
    end if
  end for
  if found=0 then
    key_buffer=append(key_buffer,scancode)
  end if
end procedure

procedure key_remove(integer scancode)
  for i=1 to length(key_buffer) do
     if key_buffer[i]=scancode then
       key_buffer=remove_line(key_buffer,i)
       exit
     end if
  end for
end procedure

function key_check(integer scancode)
   for i=1 to length(key_buffer) do
     if key_buffer[i]=scancode then
       return 1
     end if
  end for
  return 0
end function




sequence working_dir
working_dir=command_line()
working_dir=get_file_path_part(working_dir[2])

--=========================setup vspliter============================--
constant
GMID		= xControl( Geometry, "", Window1, 0, 0, 0, 0, 0, 0 ),
vsplit		= xControl( VSplitter, "", 	Window1, 200, 0, 0, 0, 0, GMID )
manage( GMID, CWindow2, {0,0}, {0,0}, {vsplit,0}, {1.0,-33} )
manage( GMID, CWindow1, {vsplit,0}, {0,0}, {1.0,0}, {1.0,-33} )
manage_now( GMID )

--=========================end setup vspliter============================--


--================================setup allegro============================--
sequence tile_bitmaps
atom the_palette
atom buffer,tile_buffer
object ret
integer window_width,window_height,workspace_width,workspace_height,tile_window_width,tile_window_height
integer view_left,view_top,tile_view_left
atom color_white,color_black,color_pink,color_green,color_blue,color_red

integer tile_width,tile_height,map_width,map_height
integer tempx,tempy
integer mapx,mapy
integer view_mapx,view_mapy,view_mapx_width,view_mapy_height
tile_width=32
tile_height=32
mapx=0
mapy=0
tempx=0
tempy=0
view_mapx=1
view_mapy=1
view_mapx_width=1
view_mapy_height=1
buffer=0
window_width=640
window_height=480
workspace_width=1280--*10
workspace_height=960--*10

map_width=workspace_width/tile_width
map_height=workspace_height/tile_height
view_mapx_width=floor(window_width/tile_width)+1
view_mapy_height=floor(window_height/tile_height)+1

view_left=0
view_top=0
tile_bitmaps={}

tile_buffer=0
tile_view_left=0
tile_window_width=300
tile_window_height=300

sequence tile_list
tile_list={}

for i=1 to map_height do
  tile_list=append(tile_list , repeat(4,map_width))
end for

--load a game make tile file
procedure load_tile_data(sequence fname)
  integer fn,tempw,temph,width_tiles,height_tiles
  integer left,top,x,y
  fn=open(fname,"r")
  tempw=real(gets(fn))
  temph=real(gets(fn))

  width_tiles=(tempw/tile_width)
  height_tiles=(temph/tile_height)

  for i=1 to height_tiles do
    for j=1 to width_tiles do
       left=real(gets(fn))
       top=real(gets(fn))
       x=real(gets(fn))
       y=real(gets(fn))

       if left=132 and top=33 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=4
       elsif left=33 and top=33 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=1
       elsif left=66 and top=33 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=2
       elsif left=99 and top=33 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=3
       elsif left=33 and top=66 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=5
       elsif left=66 and top=66 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=6
       elsif left=99 and top=66 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=7
       elsif left=132 and top=66 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=8
       elsif left=33 and top=99 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=9
       elsif left=66 and top=99 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=10
       elsif left=99 and top=99 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=11
       elsif left=33 and top=132 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=12
       elsif left=66 and top=132 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=13
       elsif left=99 and top=132 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=14
       elsif left=132 and top=132 then
       	 tile_list[ (y/tile_height)+1][ (x/tile_width)+1 ]=15
       end if

    end for
  end for

  close(fn)
end procedure


procedure tiles_load()
 sequence file_list
 --puts(1,working_dir)
 --&"\\tiles"working_dir
 --puts(1,current_dir())
 file_list=dir("tiles")
 for i=3 to length(file_list) do
 	tile_bitmaps&=load_bitmap("tiles\\tile_"&sprint(i-3)&".bmp", the_palette)
 end for

  load_tile_data("tiles.txt")

end procedure



procedure startup_allegro()
integer ret
win_set_window(getHWND(Window1))
the_palette = allocate_palette()
if allegro_init()!= 0 then
  puts(1,"init\n")
end if
if install_timer()!= 0 then
  puts(1,"timer\n")
end if
ret=reserve_voices (4, -1)
if install_sound (DIGI_AUTODETECT, MIDI_AUTODETECT, "")!= 0 then
  puts(1,"install sound\n")
end if
set_color_depth(16)
set_palette(the_palette)

color_white=rgb2(255,255,255)
color_black=rgb2(0,0,0)
color_pink=rgb2(255,0,255)
color_green=rgb2(0,255,0)
color_blue=rgb2(0,0,255)
color_red=rgb2(255,0,0)

buffer=create_bitmap(window_width,window_height)
clear_to_color(buffer,color_white)

tiles_load()

end procedure

procedure close_allegro()
  destroy_palette(the_palette)
  destroy_bitmap(buffer)

  for i=1 to length(tile_bitmaps) do
    destroy_bitmap(	tile_bitmaps[i] )
  end for

  allegro_exit()
end procedure

--load_midi
--play_midi(the_music, 1)
--play_sample(the_sample, 255, pan, pitch, 1)
--destroy_midi(the_music)
--buffer=create_bitmap(view_width,view_height)
--destroy_bitmap(buffer)
--load_sample("buzzer.wav")
--destroy_sample(buzzer_sfx)
--load_bitmap("marty.bmp", the_palette)

--================================end setup allegro==========================--




--=========================load config=========================--

sequence recent_info
recent_info=repeat("",10)

integer last_exit_code,crash_count
last_exit_code=1-- set to defalut good exit
crash_count=0

constant MAIN_VERSION=0
constant PATCH_VERSION=0
constant PROGRAM_NAME="StarCraft Editor"
constant PROGRAM_KEY="HKEY_CURRENT_USER\\SOFTWARE\\"&PROGRAM_NAME&"\\VERSION "&sprint(MAIN_VERSION)&"\\Settings"

procedure load_config()
object data
integer x,y,width,height,max
sequence size

  if regKeyExists(PROGRAM_KEY)=1 then
    width=regQueryValue(PROGRAM_KEY,"FormWidth",780)
    height=regQueryValue(PROGRAM_KEY,"FormHeight",560)
    x=regQueryValue(PROGRAM_KEY,"FormLeft",0)
    y=regQueryValue(PROGRAM_KEY,"FormTop",0)
    max=regQueryValue(PROGRAM_KEY,"FormMaximized",0)
    last_exit_code=regQueryValue(PROGRAM_KEY,"ExitCode",0)
    data=regSetValue(PROGRAM_KEY,"ExitCode",0)--reset to bad exit
    crash_count=regQueryValue(PROGRAM_KEY,"CrashNumber",0)
    for i=1 to length(recent_info) do
      recent_info[i]=regQueryValue(PROGRAM_KEY,"Recent"&sprint(i),"")	
    end for

    setCtlPosition(Window1,x,y)
    setCtlSize(Window1,width,height)
    if max=1 then
      setTimer(Window1,1001,1)	
    end if
  else
    width=780
    height=560
    size=getCtlSize(Screen)
    if size[1]<width or size[2]<height then
      puts(1,"need a screen size of at least 800 and 600\n")	
    end if
    x=floor (size[1]/2) - floor(width/2)
    if x<0 then
      x=0	
    end if
    y=floor (size[2]/2) - floor(height/2)
    if y<0 then
      y=0	
    end if
    setCtlPosition(Window1,x,y)
    setCtlSize(Window1,width,height)
    data=regSetValue(PROGRAM_KEY,"FormWidth",width)
    data=regSetValue(PROGRAM_KEY,"FormHeight",height)
    data=regSetValue(PROGRAM_KEY,"FormLeft", x )
    data=regSetValue(PROGRAM_KEY,"FormTop",  y )
    data=regSetValue(PROGRAM_KEY,"FormMaximized",0)
    data=regSetValue(PROGRAM_KEY,"ExitCode",0)
    data=regSetValue(PROGRAM_KEY,"CrashNumber",crash_count)
    for i=1 to length(recent_info) do
      data=regSetValue(PROGRAM_KEY,"Recent"&sprint(i),"")	
    end for
  end if

end procedure

procedure save_config()
object data
sequence size,pos,size2

    if isMaximized( Window1 ) then
      data=regSetValue(PROGRAM_KEY,"FormMaximized",1)

    else
      if not isMinimized( Window1 ) then
        size=getCtlSize(Window1)
        pos=getPosition(Window1)
      	data=regSetValue(PROGRAM_KEY,"FormWidth",size[1])
        data=regSetValue(PROGRAM_KEY,"FormHeight",size[2])
        size2=getCtlSize(Screen)
        if pos[1]<0 or pos[1]>size[1] then
          pos[1]=0
        end if
        if pos[2]<0 or pos[2]>size[2] then
          pos[2]=0	
        end if
        data=regSetValue(PROGRAM_KEY,"FormLeft",pos[1])
        data=regSetValue(PROGRAM_KEY,"FormTop",pos[2])
      end if
      data=regSetValue(PROGRAM_KEY,"FormMaximized",0)
      data=regSetValue(PROGRAM_KEY,"CrashNumber",crash_count)
    end if
    data=regSetValue(PROGRAM_KEY,"ExitCode",1)--reset to good exit
    for i=1 to length(recent_info) do
      data=regSetValue(PROGRAM_KEY,"Recent"&sprint(i),recent_info[i])	
    end for
end procedure

--=======================end load config=========================--


--=======================error handlering========================--


procedure program_bad_run()

--crash_file("log\\err"&sprint(crash_count)&".txt")

--crash_message("An unexpected error has occurred!\n" &
--              "Please contact gaz.com\n" &
--              "Do not delete the file \"ex.err\".\n")

if last_exit_code=0 then
  crash_count+=1
  ret=regSetValue(PROGRAM_KEY,"CrashNumber",crash_count)
  puts(1,PROGRAM_NAME&"crash last time it woz used sorry\n")	
end if

end procedure
--=======================end error handlering========================--

integer selected_tile
selected_tile=1

sequence undo_list
undo_list={}

--==============================CWindow3 events==============================--
procedure cwindow3_paint()
  atom hdc
  integer numoftile,count,xx,yy



  hdc=getDC(CWindow3)
  clear_to_color(tile_buffer,color_black)
  xx=0
  yy=0
  numoftile=floor(tile_window_width/tile_width)
  count=0
  for i=1 to length(tile_bitmaps) do

    blit(tile_bitmaps[i],tile_buffer,0,0,xx-tile_view_left,yy,tile_width,tile_height)
    if selected_tile=i then
       allegro:rect(tile_buffer,xx+2-tile_view_left,yy+2,xx-4+tile_width-tile_view_left,yy-4+tile_height,color_white)	
    end if
    xx+=tile_width
  	count+=1
  	if count=numoftile then
  		count=0
  		xx=0
  		yy+=tile_height
  	end if
  end for

  allegro:rect(tile_buffer,0-tile_view_left,0,(tile_window_width-1)-tile_view_left,(tile_window_height-1),color_red)

  blit_to_hdc(tile_buffer,hdc,0,0,0,0,tile_window_width,tile_window_height)
  releaseDC(hdc)
end procedure

procedure cwindow3_scroll()
  tile_view_left=getScrollPos( {CWindow3, SB_HORZ} )
  cwindow3_paint()
end procedure

procedure cwindow3_resize()
sequence size,pos
 size=getCtlSize( CWindow2 )

 --view width\height

 pos=getPosition(CWindow3)
 pos[2]+=window_border_height
 tile_window_width=size[1]-(window_hscrollbar_width+window_border_width)
 tile_window_height=size[2]-pos[2]

 destroy_bitmap(tile_buffer)

 tile_buffer=0--might catch a bug

 if tile_window_width<1 then
 	tile_window_width=1
 end if
 if tile_window_height<1 then
 	tile_window_height=1
 end if

 tile_buffer=create_bitmap(tile_window_width,tile_window_height)


 --if (workspace_width-window_width)<=1 then
 --  ret=w32Func( xEnableScrollBar , { getHandle( CWindow1 ), SB_HORZ	,3 } )
 --else
 --  ret=w32Func( xEnableScrollBar , { getHandle( CWindow1 ), SB_HORZ	,0 } )
 --  setWindowScrollRange ( CWindow1, SB_HORZ, 0, (workspace_width-window_width)+(tile_width), tile_width)
 --end if

end procedure

procedure cwindow3_mouse(sequence params)
integer xx,yy

  integer numoftile,count,xxx,yyy



  xxx=0
  yyy=0
  numoftile=floor(tile_window_width/tile_width)
  count=0

  xx=floor((params[2]+tile_view_left)/tile_width)+1
  yy=floor( (params[3])/tile_height)

  if params[1]=LeftDown then
  	

  for i=1 to length(tile_bitmaps) do
    xxx+=1
  	count+=1
  	if xx=xxx and yy=yyy then
  	  selected_tile=i
  	
  	  cwindow3_paint()
      exit	
   	end if
  	if count=numoftile then
  		count=0
  		xxx=0
  		yyy+=1
  	end if
  	
  end for

end if

end procedure



--==============================CWindow1 events==============================--
procedure cwindow1_paint()
  atom hdc

  hdc=getDC(CWindow1)
  clear_to_color(buffer,color_black)

  for i=view_mapy to view_mapy_height+view_mapy do
  	for j=view_mapx to view_mapx_width+view_mapx do
  	  --textout_ex(buffer,font, sprint(j)&" "&sprint(i), ((tile_width*j)-tile_width)-view_left , ((tile_height*i)-tile_height)-view_top, color_white ,-1)
  	  if i<=map_height and j<=map_width then
        blit(tile_bitmaps[tile_list[i][j]],buffer,0,0,((tile_width*j)-tile_width)-view_left,((tile_height*i)-tile_height)-view_top,tile_width,tile_height)      	
      end if
  	end for
  end for

  for i=0 to view_left+window_width by tile_width do
    if i-view_left<window_width then
      line(buffer,i-view_left,0,i-view_left,window_height,color_white)
    end if
  end for
  for j=0 to view_top+window_height by tile_height do
    if j-view_top<window_height then
       line(buffer,0,j-view_top,window_width,j-view_top,color_white)	
    end if
  end for


  allegro:rect(buffer,0-view_left,0-view_top,(workspace_width-1)-view_left,(workspace_height-1)-view_top,color_red)


  rect(buffer, ((tile_width*mapx)-view_left)-tile_width, ((tile_height*mapy)-view_top)-tile_height, ((tile_width*mapx)-view_left), ((tile_height*mapy)-view_top), color_pink )

  blit_to_hdc(buffer,hdc,0,0,0,0,window_width,window_height)
  releaseDC(hdc)
end procedure

procedure cwindow1_scroll()
  view_left=getScrollPos( {CWindow1, SB_HORZ} )
  view_top=getScrollPos( {CWindow1, SB_VERT} )
  view_mapx=floor(view_left/tile_width)+1
  view_mapy=floor(view_top/tile_height)+1
  cwindow1_paint()
end procedure

 setScrollChange( {CWindow1,SB_HORZ},  tile_width ,(workspace_width-window_width)+(tile_width))
 setScrollChange( {CWindow1,SB_VERT},  tile_height ,(workspace_height-window_height)+tile_height)

procedure cwindow1_resize()
sequence size,pos
 size=getCtlSize( Window1 )

 --view width\height
 pos=getPosition(CWindow1)
 pos[1]-=2
 window_width=size[1]-(pos[1]+(window_border_width*2)+window_hscrollbar_width+window_border_width )
 window_height=size[2]-(window_all_height+window_vscrollbar_height+window_border_height )
 destroy_bitmap(buffer)

 buffer=0--might catch a bug
 if window_width>workspace_width then
 	window_width=workspace_width
 end if
 if window_height>workspace_height then
 	window_height=workspace_height
 end if
 if window_width<1 then
 	window_width=1
 end if
 if window_height<1 then
 	window_height=1
 end if

 buffer=create_bitmap(window_width,window_height)

 view_mapx_width=floor(window_width/tile_width)+1
 view_mapy_height=floor(window_height/tile_height)+1

 --cwindow1 scroll bars
 if view_left+window_width>workspace_width then	
   setScrollPos( {CWindow1, SB_HORZ}, (view_left-(view_left+window_width-workspace_width)) )
 end if
 if view_top+window_height>workspace_height then
   setScrollPos( {CWindow1, SB_VERT}, (view_top-(view_top+window_height-workspace_height)) )
 end if


 if (workspace_width-window_width)<=1 then
   ret=w32Func( xEnableScrollBar , { getHandle( CWindow1 ), SB_HORZ	,3 } )
 else
   ret=w32Func( xEnableScrollBar , { getHandle( CWindow1 ), SB_HORZ	,0 } )
   setWindowScrollRange ( CWindow1, SB_HORZ, 0, (workspace_width-window_width)+(tile_width), tile_width)
 end if
 if (workspace_height-window_height)<=1 then
   ret=w32Func( xEnableScrollBar , { getHandle( CWindow1 ), SB_VERT	,3 } )
 else
   ret=w32Func( xEnableScrollBar , { getHandle( CWindow1 ), SB_VERT	,0 } )
   setWindowScrollRange ( CWindow1, SB_VERT, 0,  (workspace_height-window_height)+(tile_height), tile_height)
 end if


end procedure

integer mouse_left_pressed
mouse_left_pressed=0

integer temptx,tempty
temptx=0
tempty=0

procedure cwindow1_mouse(sequence params)
integer xx,yy
  xx=floor((params[2]+view_left)/tile_width)+1
  yy=floor( (params[3]+view_top)/tile_height)+1
  if xx>0 and xx<=map_width and yy>0 and yy<=map_height then
    mapx=xx
    mapy=yy
    if tempx!=mapx or tempy!=mapy then
  	  tempx=mapx
  	  tempy=mapy
  	  cwindow1_paint()
    end if

    if params[1]=LeftDown then
      mouse_left_pressed=1
      --undo_list=append(undo_list,{mapx,mapy,tile_list[mapy][mapx]})
      --tile_list[mapy][mapx]=selected_tile
      cwindow1_paint()
    elsif params[1]=LeftUp then
      mouse_left_pressed=0
    end if

   if temptx!=mapx or tempty!=mapy then	
    if mouse_left_pressed=1  then
      if tile_list[mapy][mapx]!=selected_tile then
        undo_list=append(undo_list,{mapx,mapy,tile_list[mapy][mapx]})
        tile_list[mapy][mapx]=selected_tile
        cwindow1_paint()	
        temptx=mapx
        tempty=mapy
      end if
    end if
   end if

  end if

end procedure



--==========================main window menu setup====================--
constant Menu_101 = createEx( Menu, "File", Window1, 0, 0, 0, 0, 0, 0 )
constant MenuItem_102 = xControl( PicMenuItem, "New", Menu_101, 0, 0, 0, 0, 0, "images\\New.bmp" )
constant MenuItem_103 = xControl( PicMenuItem, "Open", Menu_101, 0, 0, 0, 0, 0, "images\\Open.bmp" )

constant Menu_121 = createEx( Menu, "Recent Files", Menu_101, 0, 0, 0, 0, 0, 0 )
integer
MenuItem_recent1,
MenuItem_recent2,
MenuItem_recent3,
MenuItem_recent4,
MenuItem_recent5,
MenuItem_recent6,
MenuItem_recent7,
MenuItem_recent8,
MenuItem_recent9,
MenuItem_recent10

procedure mainmenu_recent_item_onClick(integer self, integer event, sequence params)

end procedure

if length(recent_info[1])>0 then
  MenuItem_recent1 = createEx( MenuItem, get_file_name_part(recent_info[1]), Menu_121, 0, 0, 0, 0, 0, 0 )
  setHandler( MenuItem_recent1, w32HClick, routine_id("mainmenu_recent_item_onClick"))	
end if
if length(recent_info[2])>0 then
  MenuItem_recent2 = createEx( MenuItem, get_file_name_part(recent_info[2]), Menu_121, 0, 0, 0, 0, 0, 0 )
  setHandler( MenuItem_recent2, w32HClick, routine_id("mainmenu_recent_item_onClick"))
end if
if length(recent_info[3])>0 then
  MenuItem_recent3 = createEx( MenuItem, get_file_name_part(recent_info[3]), Menu_121, 0, 0, 0, 0, 0, 0 )
  setHandler( MenuItem_recent3, w32HClick, routine_id("mainmenu_recent_item_onClick"))	
end if
if length(recent_info[4])>0 then
  MenuItem_recent4 = createEx( MenuItem, get_file_name_part(recent_info[4]), Menu_121, 0, 0, 0, 0, 0, 0 )
  setHandler( MenuItem_recent4, w32HClick, routine_id("mainmenu_recent_item_onClick"))	
end if
if length(recent_info[5])>0 then
  MenuItem_recent5 = createEx( MenuItem, get_file_name_part(recent_info[5]), Menu_121, 0, 0, 0, 0, 0, 0 )
  setHandler( MenuItem_recent5, w32HClick, routine_id("mainmenu_recent_item_onClick"))	
end if
if length(recent_info[6])>0 then
  MenuItem_recent6 = createEx( MenuItem, get_file_name_part(recent_info[6]), Menu_121, 0, 0, 0, 0, 0, 0 )
  setHandler( MenuItem_recent6, w32HClick, routine_id("mainmenu_recent_item_onClick"))	
end if
if length(recent_info[7])>0 then
  MenuItem_recent7 = createEx( MenuItem, get_file_name_part(recent_info[7]), Menu_121, 0, 0, 0, 0, 0, 0 )
  setHandler( MenuItem_recent7, w32HClick, routine_id("mainmenu_recent_item_onClick"))	
end if
if length(recent_info[8])>0 then
  MenuItem_recent8 = createEx( MenuItem, get_file_name_part(recent_info[8]), Menu_121, 0, 0, 0, 0, 0, 0 )
  setHandler( MenuItem_recent8, w32HClick, routine_id("mainmenu_recent_item_onClick"))	
end if
if length(recent_info[9])>0 then
  MenuItem_recent9 = createEx( MenuItem, get_file_name_part(recent_info[9]), Menu_121, 0, 0, 0, 0, 0, 0 )
  setHandler( MenuItem_recent9, w32HClick, routine_id("mainmenu_recent_item_onClick"))
end if

if length(recent_info[10])>0 then
  MenuItem_recent10 = createEx( MenuItem, get_file_name_part(recent_info[10]), Menu_121, 0, 0, 0, 0, 0, 0 )
  setHandler( MenuItem_recent10, w32HClick, routine_id("mainmenu_recent_item_onClick"))
end if

constant MenuItem_spacer1 = createEx( MenuItem, "", Menu_101, 0, 0, 0, 0, 0, 0 )
constant MenuItem_104 = xControl( PicMenuItem, "Save", Menu_101, 0, 0, 0, 0, 0, "images\\Save.bmp" )
constant MenuItem_105 = xControl( PicMenuItem, "Save As", Menu_101, 0, 0, 0, 0, 0, "images\\SaveAs.bmp" )
constant MenuItem_spacer2 = createEx( MenuItem, "", Menu_101, 0, 0, 0, 0, 0, 0 )

constant MenuItem_106 = createEx( MenuItem, "Settings", Menu_101, 0, 0, 0, 0, 0, 0 )
constant MenuItem_spacer8 = createEx( MenuItem, "", Menu_101, 0, 0, 0, 0, 0, 0 )

constant MenuItem_107 = xControl( PicMenuItem, "Exit", Menu_101, 0, 0, 0, 0, 0, "images\\Exit.bmp" )

constant Menu_131 = createEx( Menu, "Edit", Window1, 0, 0, 0, 0, 0, 0 )


procedure mainmenu_undo_onClick(integer self, integer event, sequence params)
sequence data
  if length(undo_list) then
    data=undo_list[length(undo_list)]
  	undo_list=undo_list[1..length(undo_list)-1]
  	tile_list[ data[2] ][ data[1] ]=data[3]
  	cwindow1_paint()
  	--?length(undo_list)
  end if	
end procedure

constant MenuItem_108 = createEx( MenuItem, "Undo", Menu_131, 0, 0, 0, 0, 0, 0 )
setHandler( MenuItem_108, w32HClick, routine_id("mainmenu_undo_onClick"))	




--==========================end main window menu setup====================--

atom bmap_new,bmap_open,bmap_save,bmap_spacer
bmap_new=loadBitmapFromFile("images\\new_l.bmp")
bmap_open=loadBitmapFromFile("images\\open_l.bmp")
bmap_save=loadBitmapFromFile("images\\save_l.bmp")

bmap_spacer=loadBitmapFromFile("images\\spacer.bmp")
--===================================main window toolbar setup===============================--
integer pic_button1
--24*24--bitmap
--29 button w
--9 spacer w
procedure toolbar_button_new_click(integer id)

end procedure
pic_button1=create_toolbar_button({toolbar1,1,0,bmap_new,routine_id("toolbar_button_new_click"),"New" })

procedure toolbar_button_open_click(integer id)

end procedure
pic_button1=create_toolbar_button({toolbar1,30,0,bmap_open,routine_id("toolbar_button_open_click"), "Open" })

procedure toolbar_button_save_click(integer id)

end procedure
pic_button1=create_toolbar_button({toolbar1,59,0,bmap_save,routine_id("toolbar_button_save_click"), "Save" })

pic_button1=create_toolbar_button({toolbar1,88,0,bmap_spacer,-1,""})
toolbar_button_set_enable(pic_button1,0)

--------------------------------------------------------------------------------
procedure Window1_onClose (integer self, integer event, sequence params)--params is ()
  ret = message_box("Do you wish to exit?","StarCraft Editor",MB_YESNO)

  if ret=IDNO then
    returnValue(1)
    return
  end if


  save_config()
  close_allegro()
end procedure
setHandler( Window1, w32HClose, routine_id("Window1_onClose"))
--------------------------------------------------------------------------------
procedure Window1_onKeyDown (integer self, integer event, sequence params)--params is ( atom scanCode, atom shift )
  key_add(params[1])

  if params[1]=VK_SPACE then
  	mainmenu_undo_onClick(0, 0, {})
  end if
end procedure
setHandler( Window1, w32HKeyDown, routine_id("Window1_onKeyDown"))
--------------------------------------------------------------------------------
procedure Window1_onKeyUp (integer self, integer event, sequence params)--params is ( int scanCode, int shift )
  key_remove(params[1])
end procedure
setHandler( Window1, w32HKeyUp, routine_id("Window1_onKeyUp"))
--------------------------------------------------------------------------------
procedure Window1_onOpen (integer self, integer event, sequence params)--params is ()
  startup_allegro()
  centerwindow(Window1)
  setCtlPosition(CWindow1,200,window_toolbar_height)
  setCtlPosition(CWindow2,0,window_toolbar_height)
  setCtlPosition(CWindow3,0,200)
  load_config()
  program_bad_run()
end procedure
setHandler( Window1, w32HOpen, routine_id("Window1_onOpen"))
--------------------------------------------------------------------------------
procedure Window1_onResize (integer self, integer event, sequence params)--params is ( int style, int cx, int cy )
  sequence size
  size=getCtlSize(Window1)
  --setCtlSize(CWindow1,size[1]-(200+(window_border_width*2)),size[2]-window_all_height)
  --setCtlSize(CWindow2,200,size[2]-window_all_height)

  setCtlSize(toolbar1,size[1],window_toolbar_height)

end procedure
setHandler( Window1, w32HResize, routine_id("Window1_onResize"))
--------------------------------------------------------------------------------
procedure Window1_onTimer (integer self, integer event, sequence params)--params is ( int timerId)
  if params[1]=1001 then
  	showWindow(Window1,SW_SHOWMAXIMIZED)
    killTimer(Window1,1001)
  end if
end procedure
setHandler( Window1, w32HTimer, routine_id("Window1_onTimer"))
--------------------------------------------------------------------------------
procedure CWindow2_onResize (integer self, integer event, sequence params)--params is ( int style, int cx, int cy )
  sequence size,pos
  size=getCtlSize(CWindow2)
  pos=getPosition(CWindow3)
  setCtlSize(CWindow3,size[1],size[2]-pos[2])
end procedure
setHandler( CWindow2, w32HResize, routine_id("CWindow2_onResize"))
--------------------------------------------------------------------------------
procedure CWindow1_onMouse (integer self, integer event, sequence params)--params is ( int event, int x, int y, int shift, int wheelmove )
  cwindow1_mouse(params)
end procedure
setHandler( CWindow1, w32HMouse, routine_id("CWindow1_onMouse"))
--------------------------------------------------------------------------------
procedure CWindow1_onPaint (integer self, integer event, sequence params)--params is ( int x1, int y1, int x2, int y2 )
  setTimer(CWindow1,1001,0)
end procedure
setHandler( CWindow1, w32HPaint, routine_id("CWindow1_onPaint"))
--------------------------------------------------------------------------------
procedure CWindow1_onScroll (integer self, integer event, sequence params)--params is ( int pos )
  cwindow1_scroll()
end procedure
setHandler( CWindow1, w32HScroll, routine_id("CWindow1_onScroll"))
--------------------------------------------------------------------------------
procedure CWindow1_onResize (integer self, integer event, sequence params)--params is ( int style, int cx, int cy )
  cwindow1_resize()
end procedure
setHandler( CWindow1, w32HResize, routine_id("CWindow1_onResize"))
--------------------------------------------------------------------------------
procedure CWindow1_onTimer (integer self, integer event, sequence params)--params is ( int timerId)
  if params[1]=1001 then--paint window
  	cwindow1_paint()
  	killTimer(CWindow1,1001)
  end if
end procedure
setHandler( CWindow1, w32HTimer, routine_id("CWindow1_onTimer"))
--------------------------------------------------------------------------------
procedure CWindow3_onMouse (integer self, integer event, sequence params)--params is ( int event, int x, int y, int shift, int wheelmove )
  cwindow3_mouse(params)
end procedure
setHandler( CWindow3, w32HMouse, routine_id("CWindow3_onMouse"))
--------------------------------------------------------------------------------
procedure CWindow3_onPaint (integer self, integer event, sequence params)--params is ( int x1, int y1, int x2, int y2 )
  setTimer(CWindow3,1001,0)
end procedure
setHandler( CWindow3, w32HPaint, routine_id("CWindow3_onPaint"))
--------------------------------------------------------------------------------
procedure CWindow3_onScroll (integer self, integer event, sequence params)--params is ( int pos )
  cwindow3_scroll()
end procedure
setHandler( CWindow3, w32HScroll, routine_id("CWindow3_onScroll"))
--------------------------------------------------------------------------------
procedure CWindow3_onResize (integer self, integer event, sequence params)--params is ( int style, int cx, int cy )
  cwindow3_resize()
end procedure
setHandler( CWindow3, w32HResize, routine_id("CWindow3_onResize"))
--------------------------------------------------------------------------------
procedure CWindow3_onTimer (integer self, integer event, sequence params)--params is ( int timerId)
  if params[1]=1001 then--paint window
  	cwindow3_paint()
  	killTimer(CWindow3,1001)
  end if
end procedure
setHandler( CWindow3, w32HTimer, routine_id("CWindow3_onTimer"))
--------------------------------------------------------------------------------
procedure toolbar1_onMouse (integer self, integer event, sequence params)--params is ( int event, int x, int y, int shift, int wheelmove )
  mouse_toolbar(self,params)
end procedure
setHandler( toolbar1, w32HMouse, routine_id("toolbar1_onMouse"))
--------------------------------------------------------------------------------
procedure toolbar1_onPaint (integer self, integer event, sequence params)--params is ( int x1, int y1, int x2, int y2 )
  draw_toolbar(self)
end procedure
setHandler( toolbar1, w32HPaint, routine_id("toolbar1_onPaint"))


WinMain( Window1,Normal )
--this program has 1026 lines without including this line. If there is a discrepancy please send this file zipped to Judith.
